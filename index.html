< !DOCTYPE html><html lang="pt-br"><head><meta charset="UTF-8"><meta name="viewport"content="width=device-width, initial-scale=1.0"><title>Reação em Cadeia - Card Game Químico</title><style>@import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Orbitron:wght@700&display=swap');

:root {
    --bg-color: #1a1a2e;
    --player-color: #16213e;
    --opponent-color: #533483;
    --reaction-color: #e94560;
    --card-bg: #f0f0f0;
    --card-border: #333;
    --text-light: #f1f1f1;
    --text-dark: #111;
    --damage-color: #ff4757;
    --stable-color: #2ed573;
    --hyper-instability-color: #f9ca24;
    /* --- ALTERAÇÃO: Nova cor para a instabilidade de massa --- */
    --superheavy-instability-color: #ff6b81;
}

body {
    font-family: 'Roboto Mono', monospace;
    background-color: var(--bg-color);
    color: var(--text-light);
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
}

#game-container {
    width: 100%;
    max-width: 1200px;
    height: 95vh;
    display: grid;
    grid-template-rows: 1fr 2fr 1fr;
    grid-template-columns: 3fr 1fr;
    gap: 10px;
    padding: 10px;
    box-sizing: border-box;
}

/* Áreas do Jogo */
.player-area {
    border-radius: 10px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    position: relative;
}

#opponent-area {
    background-color: var(--opponent-color);
    grid-row: 1 / 2;
    grid-column: 1 / 2;
}

#player-area {
    background-color: var(--player-color);
    grid-row: 3 / 4;
    grid-column: 1 / 2;
}

#reaction-area {
    background-color: rgba(0, 0, 0, 0.2);
    border: 2px dashed var(--reaction-color);
    grid-row: 2 / 3;
    grid-column: 1 / 2;
    border-radius: 10px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: border-color 0.3s, box-shadow 0.3s;
}

/* --- ALTERAÇÃO: Animações para os dois tipos de instabilidade --- */
#reaction-area.hyper-unstable {
    border-color: var(--hyper-instability-color);
    animation: pulse-yellow 1s infinite;
}

#reaction-area.superheavy-unstable {
    border-color: var(--superheavy-instability-color);
    animation: pulse-red 1s infinite;
}

@keyframes pulse-yellow {
    0% {
        box-shadow: 0 0 0 0 var(--hyper-instability-color);
    }

    70% {
        box-shadow: 0 0 10px 15px rgba(249, 202, 36, 0);
    }

    100% {
        box-shadow: 0 0 0 0 rgba(249, 202, 36, 0);
    }
}

@keyframes pulse-red {
    0% {
        box-shadow: 0 0 0 0 var(--superheavy-instability-color);
    }

    70% {
        box-shadow: 0 0 10px 15px rgba(255, 107, 129, 0);
    }

    100% {
        box-shadow: 0 0 0 0 rgba(255, 107, 129, 0);
    }
}


#game-info {
    background-color: #0f3460;
    grid-row: 1 / 4;
    grid-column: 2 / 3;
    border-radius: 10px;
    padding: 15px;
    display: flex;
    flex-direction: column;
}

.hand {
    display: flex;
    gap: 10px;
    justify-content: center;
    align-items: center;
    flex-grow: 1;
}

.card {
    width: 100px;
    height: 140px;
    background-color: var(--card-bg);
    border: 2px solid var(--card-border);
    border-radius: 8px;
    color: var(--text-dark);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 8px;
    box-sizing: border-box;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    position: relative;
    box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.3);
}

#player-hand .card:hover {
    transform: translateY(-15px) scale(1.05);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
}

.card.card-back {
    background-color: #555;
    background-image: radial-gradient(circle, #777, #555);
    cursor: default;
}

.card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.card-name {
    font-weight: 700;
    font-size: 14px;
}

.card-z {
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
    background: #ddd;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.card-symbol {
    font-family: 'Orbitron', sans-serif;
    font-size: 40px;
    text-align: center;
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
}

.card-charge {
    font-family: 'Orbitron', sans-serif;
    font-size: 22px;
    font-weight: 700;
    text-align: right;
}

.charge-positive {
    color: #d63031;
}

.charge-negative {
    color: #0984e3;
}

.charge-neutral {
    color: #636e72;
}

.player-hud {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.player-name {
    font-size: 18px;
    font-weight: 700;
}

.hp-bar {
    width: 150px;
    height: 20px;
    background-color: #555;
    border-radius: 10px;
    overflow: hidden;
    border: 1px solid var(--text-light);
}

.hp-fill {
    height: 100%;
    background-color: var(--stable-color);
    transition: width 0.5s ease;
}

.deck-info {
    display: flex;
    align-items: center;
    gap: 5px;
}

#reaction-compound {
    display: flex;
    gap: 5px;
    margin-bottom: 15px;
    min-height: 150px;
}

#reaction-compound .card {
    width: 80px;
    height: 112px;
    cursor: default;
}

#reaction-info {
    text-align: center;
}

#reaction-charge {
    font-family: 'Orbitron', sans-serif;
    font-size: 48px;
    font-weight: 700;
}

#reaction-text {
    font-size: 18px;
}

#game-log {
    flex-grow: 1;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
    padding: 10px;
    overflow-y: auto;
    display: flex;
    flex-direction: column-reverse;
}

#game-log p {
    margin: 2px 0;
    font-size: 12px;
    border-bottom: 1px solid #444;
    padding-bottom: 2px;
}

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 100;
    flex-direction: column;
    color: var(--text-light);
    text-align: center;
}

.modal-content {
    background: var(--player-color);
    padding: 30px;
    border-radius: 15px;
    border: 2px solid var(--text-light);
}

.modal h2 {
    margin-top: 0;
}

.modal button {
    font-family: 'Roboto Mono', monospace;
    font-size: 18px;
    padding: 10px 20px;
    background: var(--reaction-color);
    border: none;
    color: var(--text-light);
    border-radius: 5px;
    cursor: pointer;
    margin-top: 20px;
}

#pile-selection .pile {
    width: 100px;
    height: 140px;
    background-color: #555;
    border: 2px solid var(--text-light);
    border-radius: 8px;
    display: inline-block;
    margin: 10px;
    cursor: pointer;
    transition: transform 0.2s;
}

#pile-selection .pile:hover {
    transform: scale(1.1);
}

</style></head><body><div id="game-container"style="display: none;"><div id="opponent-area"class="player-area"><div class="player-hud"><span id="opponent-name"class="player-name">IA Quimista</span><div class="hp-bar"><div id="opponent-hp-fill"class="hp-fill"></div></div><span id="opponent-hp-text">100/100</span></div><div id="opponent-hand"class="hand"></div><div class="deck-info"style="position: absolute; bottom: 10px; right: 10px;"><span>Deck: </span><span id="opponent-deck-count">0</span></div></div><div id="reaction-area"><div id="reaction-compound"></div><div id="reaction-info"><div id="reaction-text">Composto Instável</div><div id="reaction-charge">0</div></div></div><div id="player-area"class="player-area"><div id="player-hand"class="hand"></div><div class="player-hud"style="margin-top: 10px;"><span id="player-name"class="player-name">Jogador</span><div class="hp-bar"><div id="player-hp-fill"class="hp-fill"></div></div><span id="player-hp-text">100/100</span></div><div class="deck-info"style="position: absolute; top: 10px; right: 10px;"><span>Deck: </span><span id="player-deck-count">0</span></div></div><div id="game-info"><h2>Reação em Cadeia</h2><div id="turn-indicator"style="text-align: center; margin-bottom: 10px; font-weight: bold;"></div><div id="game-log"></div></div></div><div id="start-screen"class="modal"><div class="modal-content"><h2>Bem-vindo ao Reação em Cadeia !</h2><p>Reduza a Estabilidade do seu oponente a zero.</p><p>Jogue cartas para passar a "batata quente". Se não puder combinar,
ela explode em você !</p><p>Se você estabilizar a molécula (carga=0),
o oponente sofre o dano !</p>< !-- --- ALTERAÇÃO: Adicionada nova regra na tela inicial --- --><p style="color: var(--hyper-instability-color); font-weight: bold;">CUIDADO (CARGA): Se a carga do composto passar de+6 ou -6,
ele explode no jogador que causou a instabilidade !</p><p style="color: var(--superheavy-instability-color); font-weight: bold;">CUIDADO (MASSA): Se a soma dos Números Atômicos (Z) passar de 82,
o composto se torna superpesado e explode !</p><button id="start-game-btn">Iniciar Jogo</button></div></div><div id="pile-selection-screen"class="modal"style="display: none;"><div class="modal-content"><h2>Seu oponente dividiu o deck dele.</h2><p>Escolha uma pilha para adicionar ao seu deck.</p><div id="pile-selection"><div class="pile"onclick="selectPile(0)"></div><div class="pile"onclick="selectPile(1)"></div><div class="pile"onclick="selectPile(2)"></div></div></div></div><div id="game-over-screen"class="modal"style="display: none;"><div class="modal-content"><h2 id="game-over-message"></h2><button id="restart-game-btn">Jogar Novamente</button></div></div><script>const CARD_DATABASE= {
    'H': {
        name: 'Hidrogênio', symbol: 'H', z: 1, charge: 1
    }

    ,
    'Na': {
        name: 'Sódio', symbol: 'Na⁺', z: 11, charge: 1
    }

    ,
    'K': {
        name: 'Potássio', symbol: 'K⁺', z: 19, charge: 1
    }

    ,
    'Mg': {
        name: 'Magnésio', symbol: 'Mg²', z: 12, charge: 2
    }

    ,
    'Ca': {
        name: 'Cálcio', symbol: 'Ca²', z: 20, charge: 2
    }

    ,
    'Al': {
        name: 'Alumínio', symbol: 'Al³', z: 13, charge: 3
    }

    ,
    'Fe2': {
        name: 'Ferro II', symbol: 'Fe²', z: 26, charge: 2
    }

    ,
    'F': {
        name: 'Flúor', symbol: 'F⁻', z: 9, charge: -1
    }

    ,
    'Cl': {
        name: 'Cloro', symbol: 'Cl⁻', z: 17, charge: -1
    }

    ,
    'O': {
        name: 'Oxigênio', symbol: 'O²', z: 8, charge: -2
    }

    ,
    'S': {
        name: 'Enxofre', symbol: 'S²', z: 16, charge: -2
    }

    ,
    'N': {
        name: 'Nitrogênio', symbol: 'N³', z: 7, charge: -3
    }

    ,
    'C': {
        name: 'Carbono', symbol: 'C', z: 6, charge: 4, isFlexible: true, options: [4, -4]
    }

    ,
    'P': {
        name: 'Próton', symbol: 'p⁺', z: 0, charge: 1, isCoringa: true
    }

    ,
    'E': {
        name: 'Elétron', symbol: 'e⁻', z: 0, charge: -1, isCoringa: true
    }

    ,
    'Nn': {
        name: 'Nêutron', symbol: 'n⁰', z: 1, charge: 0, isCoringa: true
    }

    ,
}

;

const INITIAL_HP=100;
const DECK_SIZE=30;
const HAND_SIZE=5;
const HYPER_INSTABILITY_THRESHOLD=6;
// --- ALTERAÇÃO: Nova constante para o limite de massa (Z) ---
const SUPERHEAVY_THRESHOLD=82;

let gameState= {}

;

const UIElements= {

    gameContainer: document.getElementById('game-container'),
    startScreen: document.getElementById('start-screen'),
    pileSelectionScreen: document.getElementById('pile-selection-screen'),
    gameOverScreen: document.getElementById('game-over-screen'),
    reactionArea: document.getElementById('reaction-area'),
    player: {
        name: document.getElementById('player-name'), hpText: document.getElementById('player-hp-text'), hpFill: document.getElementById('player-hp-fill'), hand: document.getElementById('player-hand'), deckCount: document.getElementById('player-deck-count')
    }

    ,
    opponent: {
        name: document.getElementById('opponent-name'), hpText: document.getElementById('opponent-hp-text'), hpFill: document.getElementById('opponent-hp-fill'), hand: document.getElementById('opponent-hand'), deckCount: document.getElementById('opponent-deck-count')
    }

    ,
    reaction: {
        compound: document.getElementById('reaction-compound'), charge: document.getElementById('reaction-charge'), text: document.getElementById('reaction-text')
    }

    ,
    info: {
        log: document.getElementById('game-log'), turnIndicator: document.getElementById('turn-indicator'), gameOverMessage: document.getElementById('game-over-message')
    }
}

;

function createDeck() {
    const deck=[];
    const cardPool=['H',
    'H',
    'Na',
    'K',
    'Mg',
    'Ca',
    'Fe2',
    'F',
    'F',
    'Cl',
    'Cl',
    'O',
    'O',
    'S',
    'C',
    'Al',
    'N',
    'P',
    'P',
    'E',
    'E',
    'Nn',
    'Nn'];

    for (let i=0; i < DECK_SIZE; i++) {
        deck.push( {
                ...CARD_DATABASE[cardPool[i % cardPool.length]], id: `$ {
                    cardPool[i % cardPool.length]
                }

                _$ {
                    i
                }

                `
            }

        );
    }

    return shuffle(deck);
}

function shuffle(array) {
    for (let i=array.length - 1; i > 0; i--) {
        const j=Math.floor(Math.random() * (i + 1));
        [array[i],
        array[j]]=[array[j],
        array[i]];
    }

    return array;
}

function logMessage(message) {
    const p=document.createElement('p');
    p.textContent=message;
    UIElements.info.log.prepend(p);
    console.log(message);
}

function initGame() {
    UIElements.gameOverScreen.style.display='none';
    UIElements.startScreen.style.display='none';

    gameState= {
        players: [ {
            id: 'player', name: 'Jogador', hp: INITIAL_HP, deck: [], hand: [], discard: []
        }

        ,
            {
            id: 'opponent', name: 'IA Quimista', hp: INITIAL_HP, deck: [], hand: [], discard: []
        }

        ],
        currentPlayerIndex: 0,
        reactionCompound: [],
        turn: 1,
        isGameOver: false,
        isFirstTurnOfReaction: true,
        pileSelection: {
            piles: [], chooser: null, giver: null,
        }
    }

    ;
    const opponentBaseDeck=createDeck();
    const opponentPiles=[opponentBaseDeck.slice(0, 10),
    opponentBaseDeck.slice(10, 20),
    opponentBaseDeck.slice(20, 30)];
    gameState.pileSelection.piles=opponentPiles;
    gameState.pileSelection.chooser=gameState.players[0];
    gameState.pileSelection.giver=gameState.players[1];
    UIElements.pileSelectionScreen.style.display='flex';
    UIElements.gameContainer.style.display='none';
}

function selectPile(pileIndex) {
    const {
        piles,
        chooser,
        giver
    }

    =gameState.pileSelection;
    const chosenPile=piles[pileIndex];
    chooser.deck.push(...chosenPile);

    logMessage(`$ {
            chooser.name
        }

        pegou uma pilha de 10 cartas do oponente.`);
    const remainingPiles=piles.filter((_, index)=> index !==pileIndex);
    giver.deck.push(...remainingPiles.flat());
    const playerBaseDeck=createDeck();
    const playerPiles=[playerBaseDeck.slice(0, 10),
    playerBaseDeck.slice(10, 20),
    playerBaseDeck.slice(20, 30)];
    const aiChosenIndex=Math.floor(Math.random() * 3);
    const aiChosenPile=playerPiles[aiChosenIndex];
    giver.deck.push(...aiChosenPile);
    logMessage(`A IA pegou uma pilha de 10 cartas do seu deck.`);
    const playerRemainingPiles=playerPiles.filter((_, index)=> index !==aiChosenIndex);
    chooser.deck.push(...playerRemainingPiles.flat());
    gameState.players.forEach(p=> shuffle(p.deck));
    UIElements.pileSelectionScreen.style.display='none';
    UIElements.gameContainer.style.display='grid';
    startGameLoop();
}

function startGameLoop() {
    for (let i=0; i < HAND_SIZE; i++) {
        drawCard(0);
        drawCard(1);
    }

    updateUI();
    logMessage("O jogo começou! É a sua vez.");
    UIElements.info.turnIndicator.textContent="Seu Turno";
}

function drawCard(playerIndex) {
    const player=gameState.players[playerIndex];

    if (player.deck.length===0) {
        if (player.discard.length===0) {
            logMessage(`$ {
                    player.name
                }

                não tem mais cartas para comprar !`);
            return;
        }

        player.deck=shuffle(player.discard);
        player.discard=[];

        logMessage(`$ {
                player.name
            }

            embaralhou a pilha de descarte para formar um novo deck.`);
    }

    const card=player.deck.pop();
    player.hand.push(card);
}

// --- ALTERAÇÃO PRINCIPAL: Lógica de `playCard` atualizada com a nova condição de explosão ---
function playCard(playerIndex, cardHandIndex) {
    if (gameState.isGameOver || gameState.currentPlayerIndex !==playerIndex) return;

    const player=gameState.players[playerIndex];
    const card=player.hand[cardHandIndex];

    if (card.isFlexible && card.options) {
        const chosenCharge=prompt(`Escolha a carga para $ {
                card.name
            }

            ($ {
                    card.symbol
                }

            ):\nDigite $ {
                card.options[0]
            }

            ou $ {
                card.options[1]
            }

            `, card.options[0]);
        const chargeValue=parseInt(chosenCharge);

        if (card.options.includes(chargeValue)) {
            card.charge=chargeValue;
        }

        else {
            alert("Escolha inválida. Tente novamente.");
            return;
        }
    }

    player.hand.splice(cardHandIndex, 1);
    gameState.reactionCompound.push(card);

    logMessage(`$ {
            player.name
        }

        jogou $ {
            card.name
        }

        ($ {
                card.symbol
            }

        ).`);
    updateUI();

    const {
        charge,
        damage
    }

    =calculateCompoundStats();

    // ORDEM DE VERIFICAÇÃO É CRUCIAL AQUI
    // 1. Checar por Hiper-Instabilidade de Carga
    if (Math.abs(charge) > HYPER_INSTABILITY_THRESHOLD) {
        UIElements.reactionArea.classList.add('hyper-unstable');

        setTimeout(()=> {
                logMessage(`☢️ HIPER-INSTABILIDADE ! A carga ($ {
                            charge
                        }

                    ) excedeu o limite de +/-$ {
                        HYPER_INSTABILITY_THRESHOLD
                    }

                    e explodiu !`);
                dealDamage(playerIndex, damage);
                clearReaction();
                updateUI();
                setTimeout(endTurn, 1000);
            }

            , 500);
        return;
    }

    // 2. Checar por Instabilidade Superpesada de Massa (Z)
    if (damage > SUPERHEAVY_THRESHOLD) {
        UIElements.reactionArea.classList.add('superheavy-unstable');

        setTimeout(()=> {
                logMessage(`⚛️ INSTABILIDADE SUPERPESADA ! A massa total (Z=$ {
                            damage
                        }

                    ) excedeu o limite de $ {
                        SUPERHEAVY_THRESHOLD
                    }

                    e explodiu !`);
                dealDamage(playerIndex, damage);
                clearReaction();
                updateUI();
                setTimeout(endTurn, 1000);
            }

            , 500);
        return;
    }

    // 3. Checar por Estabilização
    if (charge===0) {
        const opponentIndex=1 - playerIndex;

        logMessage(`✅ MOLÉCULA ESTÁVEL ! $ {
                gameState.players[opponentIndex].name
            }

            sofreu $ {
                damage
            }

            de dano.`);
        dealDamage(opponentIndex, damage);
        clearReaction();
        updateUI();
        setTimeout(endTurn, 1000);
        return;
    }

    gameState.isFirstTurnOfReaction=false;
    setTimeout(endTurn, 1000);
}

function calculateCompoundStats() {
    return gameState.reactionCompound.reduce((acc, card)=> {
            acc.charge +=card.charge; acc.damage +=card.z; return acc;
        }

        , {
            charge: 0, damage: 0
        }

    );
}

function dealDamage(playerIndex, amount) {
    const player=gameState.players[playerIndex];
    player.hp=Math.max(0, player.hp - amount);

    logMessage(`$ {
            player.name
        }

        agora tem $ {
            player.hp
        }

        de Estabilidade.`);

    if (player.hp <=0) {
        gameState.isGameOver=true;
        const winner=gameState.players[1 - playerIndex];

        UIElements.info.gameOverMessage.textContent=`$ {
            winner.name
        }

        venceu !`;
        UIElements.gameOverScreen.style.display='flex';
    }
}

function clearReaction() {
    const player=gameState.players[gameState.currentPlayerIndex];
    player.discard.push(...gameState.reactionCompound);
    gameState.reactionCompound=[];
    gameState.isFirstTurnOfReaction=true;
    // --- ALTERAÇÃO: Limpa ambas as classes de instabilidade ---
    UIElements.reactionArea.classList.remove('hyper-unstable', 'superheavy-unstable');
    logMessage("O composto foi removido do campo.");
}

function endTurn() {
    if (gameState.isGameOver) return;
    gameState.currentPlayerIndex=1 - gameState.currentPlayerIndex;
    const nextPlayer=gameState.players[gameState.currentPlayerIndex];

    logMessage(`Turno de $ {
            nextPlayer.name
        }

        .`);
    startTurn();
}

function startTurn() {
    if (gameState.isGameOver) return;
    drawCard(gameState.currentPlayerIndex);
    updateUI();
    const player=gameState.players[gameState.currentPlayerIndex];
    const canPlay=player.hand.length>0;

    if (gameState.reactionCompound.length > 0 && !gameState.isFirstTurnOfReaction) {
        if ( !canPlay) {
            const {
                damage
            }

            =calculateCompoundStats();

            logMessage(`💥 EXPLOSÃO ! $ {
                    player.name
                }

                não pôde combinar e sofreu $ {
                    damage
                }

                de dano !`);
            dealDamage(gameState.currentPlayerIndex, damage);
            clearReaction();
            updateUI();
            setTimeout(endTurn, 2000);
            return;
        }
    }

    if (gameState.currentPlayerIndex===1) {
        UIElements.info.turnIndicator.textContent="IA está pensando...";
        setTimeout(runAITurn, 1500);
    }

    else {
        UIElements.info.turnIndicator.textContent="Seu Turno";
    }
}

// --- ALTERAÇÃO: IA atualizada para evitar a instabilidade de massa ---
function runAITurn() {
    const ai=gameState.players[1];
    const compoundStats=calculateCompoundStats();

    // Filtra jogadas seguras que não violam NENHUMA regra de instabilidade
    const playableCards=ai.hand.map((card, index)=> ( {
                card, index
            }

        )) .filter(( {
                card
            }

        )=> {
            const newCharge=compoundStats.charge + card.charge;
            const newDamage=compoundStats.damage + card.z;
            return Math.abs(newCharge) <=HYPER_INSTABILITY_THRESHOLD && newDamage <=SUPERHEAVY_THRESHOLD;
        }

    );

    if (playableCards.length===0 && ai.hand.length > 0) {
        logMessage("IA não tem jogadas seguras e é forçada a se explodir!");
        // Escolhe a jogada que causa o menor dano (lógica simples)
        let leastDamageIndex=0;
        let minDamage=Infinity;

        ai.hand.forEach((card, index)=> {
                const potentialDamage=compoundStats.damage + card.z;

                if (potentialDamage < minDamage) {
                    minDamage=potentialDamage; leastDamageIndex=index;
                }
            }

        );
        playCard(1, leastDamageIndex);
        return;
    }

    for (const {
            card, index
        }

        of playableCards) {
        if (compoundStats.charge + card.charge===0) {
            logMessage("IA encontrou uma jogada para estabilizar a molécula!");
            playCard(1, index);
            return;
        }
    }

    if (gameState.reactionCompound.length > 0 && !gameState.isFirstTurnOfReaction && playableCards.length > 0) {
        logMessage("IA é forçada a jogar e escolhe a primeira carta segura.");
        playCard(1, playableCards[0].index);
        return;
    }

    if (gameState.reactionCompound.length===0 && ai.hand.length > 0) {
        let cardToPlayIndex=0;
        let lowestCharge=100;

        for(let i=0; i<ai.hand.length; i++) {
            if(Math.abs(ai.hand[i].charge) < lowestCharge) {
                lowestCharge=Math.abs(ai.hand[i].charge);
                cardToPlayIndex=i;
            }
        }

        logMessage("IA inicia uma nova reação com uma carta de baixa carga.");
        playCard(1, cardToPlayIndex);
        return;
    }
}

function renderCard(card, isBack=false) {
    const cardEl=document.createElement('div');
    cardEl.classList.add('card');

    if (isBack) {
        cardEl.classList.add('card-back');
        return cardEl;
    }

    const chargeClass=card.charge>0 ? 'charge-positive' : (card.charge < 0 ? 'charge-negative' : 'charge-neutral');

    cardEl.innerHTML=`<div class="card-header"><span class="card-name">$ {
        card.name
    }

    </span><span class="card-z">$ {
        card.z
    }

    </span></div><div class="card-symbol">$ {
        card.symbol
    }

    </div><div class="card-charge ${chargeClass}">$ {
        card.charge>0 ? '+': ''
    }

    $ {
        card.charge
    }

    </div>`;
    return cardEl;
}

function updateUI() {
    if (gameState.isGameOver) return;
    const player=gameState.players[0];

    UIElements.player.hpText.textContent=`$ {
        player.hp
    }

    /$ {
        INITIAL_HP
    }

    `;

    UIElements.player.hpFill.style.width=`$ {
        (player.hp / INITIAL_HP) * 100
    }

    %`;
    UIElements.player.deckCount.textContent=player.deck.length;
    UIElements.player.hand.innerHTML='';

    player.hand.forEach((card, index)=> {
            const cardEl=renderCard(card); if (gameState.currentPlayerIndex===0) {
                cardEl.addEventListener('click', ()=> playCard(0, index));
            }

            UIElements.player.hand.appendChild(cardEl);
        }

    );
    const opponent=gameState.players[1];

    UIElements.opponent.hpText.textContent=`$ {
        opponent.hp
    }

    /$ {
        INITIAL_HP
    }

    `;

    UIElements.opponent.hpFill.style.width=`$ {
        (opponent.hp / INITIAL_HP) * 100
    }

    %`;
    UIElements.opponent.deckCount.textContent=opponent.deck.length;
    UIElements.opponent.hand.innerHTML='';

    opponent.hand.forEach(()=> {
            UIElements.opponent.hand.appendChild(renderCard(null, true));
        }

    );
    UIElements.reaction.compound.innerHTML='';

    gameState.reactionCompound.forEach(card=> {
            UIElements.reaction.compound.appendChild(renderCard(card));
        }

    );

    const {
        charge
    }

    =calculateCompoundStats();

    UIElements.reaction.charge.textContent=charge>0 ? `+$ {
        charge
    }

    ` : charge;
    UIElements.reaction.charge.className=charge>0 ? 'charge-positive' : (charge < 0 ? 'charge-negative' : 'charge-neutral');
}

document.getElementById('start-game-btn').addEventListener('click', initGame);
document.getElementById('restart-game-btn').addEventListener('click', initGame);
</script></body></html>
